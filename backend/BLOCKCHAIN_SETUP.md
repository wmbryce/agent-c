# üîó Blockchain Integration Guide

This guide explains how to write and interact with smart contracts in your Go project.

## üìã Table of Contents

1. [Quick Start](#quick-start)
2. [Architecture Overview](#architecture-overview)
3. [Environment Configuration](#environment-configuration)
4. [Writing Smart Contracts](#writing-smart-contracts)
5. [Generating Go Bindings](#generating-go-bindings)
6. [Using Contracts in Controllers](#using-contracts-in-controllers)
7. [API Endpoints](#api-endpoints)
8. [Testing](#testing)
9. [Best Practices](#best-practices)

## üöÄ Quick Start

### 1. Install Prerequisites

```bash
# Install Solidity compiler
brew install solidity  # macOS
# or download from https://soliditylang.org

# Install abigen (Go binding generator)
go install github.com/ethereum/go-ethereum/cmd/abigen@latest

# Install Hardhat or Ganache for local testing
npm install -g hardhat
# or
npm install -g ganache
```

### 2. Configure Environment

Add to your `.env` file:

```bash
# Ethereum Configuration
ETHEREUM_RPC_URL="http://localhost:8545"  # Local node
# ETHEREUM_RPC_URL="https://mainnet.infura.io/v3/YOUR-PROJECT-ID"  # Mainnet
# ETHEREUM_RPC_URL="https://sepolia.infura.io/v3/YOUR-PROJECT-ID"  # Sepolia testnet

# Private key for signing transactions (without 0x prefix)
ETHEREUM_PRIVATE_KEY="your-private-key-here"
```

### 3. Start Local Blockchain (for testing)

```bash
# Option 1: Hardhat
npx hardhat node

# Option 2: Ganache
ganache-cli

# Option 3: Anvil (Foundry)
anvil
```

### 4. Test the API

```bash
# Start your server
cd backend
go run main.go

# Get blockchain info
curl -X GET http://localhost:5000/api/v1/blockchain/info \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# Get ETH balance
curl -X POST http://localhost:5000/api/v1/blockchain/balance \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb4"}'
```

## üèóÔ∏è Architecture Overview

The blockchain integration follows the same clean architecture pattern as the rest of your project:

```
backend/
‚îú‚îÄ‚îÄ platform/blockchain/          # Infrastructure Layer
‚îÇ   ‚îî‚îÄ‚îÄ ethereum.go              # Ethereum client & connection management
‚îÇ
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ models/                  # Business Logic Layer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contract_model.go    # Request/response structures
‚îÇ   ‚îú‚îÄ‚îÄ controllers/             
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contract_controller.go  # API handlers for blockchain
‚îÇ   ‚îî‚îÄ‚îÄ contracts/               # Generated contract bindings
‚îÇ       ‚îî‚îÄ‚îÄ erc20_token.go       # (generated by abigen)
‚îÇ
‚îú‚îÄ‚îÄ pkg/
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contract_utils.go    # Helper functions (wei/eth conversion)
‚îÇ   ‚îî‚îÄ‚îÄ routes/
‚îÇ       ‚îî‚îÄ‚îÄ private_routes.go    # Blockchain API routes
‚îÇ
‚îî‚îÄ‚îÄ contracts/                    # Smart Contract Source Code
    ‚îú‚îÄ‚îÄ ERC20.sol                # Example ERC20 token
    ‚îî‚îÄ‚îÄ YourContract.sol         # Your custom contracts
```

## ‚öôÔ∏è Environment Configuration

### Development (Local)

```bash
# .env
ETHEREUM_RPC_URL="http://localhost:8545"
ETHEREUM_PRIVATE_KEY="ac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80"  # Hardhat account #0
```

### Testnet (Sepolia)

```bash
# .env
ETHEREUM_RPC_URL="https://sepolia.infura.io/v3/YOUR-PROJECT-ID"
ETHEREUM_PRIVATE_KEY="your-testnet-private-key"
```

### Mainnet (Production)

```bash
# .env
ETHEREUM_RPC_URL="https://mainnet.infura.io/v3/YOUR-PROJECT-ID"
ETHEREUM_PRIVATE_KEY="your-mainnet-private-key"  # ‚ö†Ô∏è Keep this VERY secure!
```

> ‚ö†Ô∏è **Security Warning**: Never commit private keys to Git! Use secrets management in production.

## üìù Writing Smart Contracts

### Step 1: Create Your Contract

Create a Solidity file in `contracts/`:

```solidity
// contracts/MyToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract MyToken {
    string public name = "My Token";
    mapping(address => uint256) public balances;
    
    function mint(uint256 amount) public {
        balances[msg.sender] += amount;
    }
    
    function getBalance(address account) public view returns (uint256) {
        return balances[account];
    }
}
```

### Step 2: Compile the Contract

```bash
cd contracts

# Create build directory
mkdir -p build

# Compile to ABI and bytecode
solc --abi --bin MyToken.sol -o build/

# Output files:
# - build/MyToken.abi (contract interface)
# - build/MyToken.bin (contract bytecode)
```

## üîß Generating Go Bindings

### Step 3: Generate Go Code

```bash
# From contracts/ directory
abigen --abi=build/MyToken.abi \
       --bin=build/MyToken.bin \
       --pkg=contracts \
       --type=MyToken \
       --out=../app/contracts/my_token.go
```

This generates a Go file with:
- Type-safe contract methods
- Automatic transaction management
- Event filtering helpers

### What Gets Generated

```go
// app/contracts/my_token.go (auto-generated)
package contracts

type MyToken struct {
    // ... contract binding code
}

// Constructor
func NewMyToken(address common.Address, client *ethclient.Client) (*MyToken, error)

// Deploy function
func DeployMyToken(auth *bind.TransactOpts, client *ethclient.Client) (common.Address, *types.Transaction, *MyToken, error)

// Read methods (view/pure functions)
func (t *MyToken) Name(opts *bind.CallOpts) (string, error)
func (t *MyToken) GetBalance(opts *bind.CallOpts, account common.Address) (*big.Int, error)

// Write methods (state-changing functions)
func (t *MyToken) Mint(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error)
```

## üíª Using Contracts in Controllers

### Create a Controller for Your Contract

```go
// app/controllers/mytoken_controller.go
package controllers

import (
    "github.com/create-go-app/fiber-go-template/app/contracts"
    "github.com/create-go-app/fiber-go-template/platform/blockchain"
    "github.com/ethereum/go-ethereum/common"
    "github.com/gofiber/fiber/v2"
    "math/big"
)

// MintTokens func mints tokens to the caller's address
func MintTokens(c *fiber.Ctx) error {
    var request struct {
        ContractAddress string `json:"contract_address"`
        Amount          string `json:"amount"`
    }
    
    if err := c.BodyParser(&request); err != nil {
        return c.Status(400).JSON(fiber.Map{"error": err.Error()})
    }
    
    // Connect to blockchain
    ethClient, err := blockchain.NewEthereumClient()
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    defer ethClient.Close()
    
    // Load contract
    contractAddr := common.HexToAddress(request.ContractAddress)
    token, err := contracts.NewMyToken(contractAddr, ethClient.Client)
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    
    // Parse amount
    amount := new(big.Int)
    amount.SetString(request.Amount, 10)
    
    // Get transaction options
    auth, err := ethClient.GetTransactOpts()
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    
    // Call contract method
    tx, err := token.Mint(auth, amount)
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    
    return c.JSON(fiber.Map{
        "success": true,
        "tx_hash": tx.Hash().Hex(),
    })
}

// GetTokenBalance func gets token balance for an address
func GetTokenBalance(c *fiber.Ctx) error {
    var request struct {
        ContractAddress string `json:"contract_address"`
        Address         string `json:"address"`
    }
    
    if err := c.BodyParser(&request); err != nil {
        return c.Status(400).JSON(fiber.Map{"error": err.Error()})
    }
    
    // Connect to blockchain
    ethClient, err := blockchain.NewEthereumClient()
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    defer ethClient.Close()
    
    // Load contract
    contractAddr := common.HexToAddress(request.ContractAddress)
    token, err := contracts.NewMyToken(contractAddr, ethClient.Client)
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    
    // Call view function (no gas cost)
    addr := common.HexToAddress(request.Address)
    balance, err := token.GetBalance(ethClient.GetCallOpts(), addr)
    if err != nil {
        return c.Status(500).JSON(fiber.Map{"error": err.Error()})
    }
    
    return c.JSON(fiber.Map{
        "address": request.Address,
        "balance": balance.String(),
    })
}
```

### Add Routes

```go
// pkg/routes/private_routes.go
route.Post("/mytoken/mint", middleware.JWTProtected(), controllers.MintTokens)
route.Post("/mytoken/balance", middleware.JWTProtected(), controllers.GetTokenBalance)
```

## üåê API Endpoints

### Built-in Endpoints

#### Get Blockchain Info
```bash
GET /api/v1/blockchain/info
```

#### Get ETH Balance
```bash
POST /api/v1/blockchain/balance
Content-Type: application/json

{
  "address": "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb4"
}
```

#### Get Transaction Receipt
```bash
POST /api/v1/blockchain/receipt
Content-Type: application/json

{
  "tx_hash": "0x123..."
}
```

## üß™ Testing

### Unit Testing with Mock Client

```go
package controllers

import (
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestMintTokens(t *testing.T) {
    // Setup mock Ethereum client
    // ... test implementation
}
```

### Integration Testing

1. Start local blockchain: `npx hardhat node`
2. Deploy test contract
3. Run API tests against local chain

## ‚úÖ Best Practices

### 1. Gas Management

```go
// Estimate gas before sending transaction
auth, _ := ethClient.GetTransactOpts()
auth.GasLimit = 300000  // Set appropriate limit
auth.GasPrice = suggestedPrice.Mul(suggestedPrice, big.NewInt(110)).Div(suggestedPrice, big.NewInt(100))  // +10%
```

### 2. Error Handling

```go
// Always check transaction receipt
receipt, err := ethClient.GetTransactionReceipt(tx.Hash().Hex())
if err != nil {
    // Handle error
}
if receipt.Status == 0 {
    // Transaction failed
}
```

### 3. Read vs Write Operations

- **Read** (view/pure): Free, instant, use `GetCallOpts()`
- **Write** (state-changing): Costs gas, takes time, use `GetTransactOpts()`

### 4. Security

- ‚úÖ Validate all addresses
- ‚úÖ Check balances before transfers
- ‚úÖ Use environment variables for keys
- ‚úÖ Implement rate limiting on expensive operations
- ‚úÖ Add authentication (already done with JWT)
- ‚ùå Never expose private keys in responses
- ‚ùå Never log private keys

### 5. Connection Management

```go
// Always close client when done
ethClient, err := blockchain.NewEthereumClient()
defer ethClient.Close()
```

## üìö Common Patterns

### Pattern 1: Deploy and Save Contract

```go
// Deploy contract
addr, tx, instance, err := contracts.DeployMyToken(auth, client)

// Save contract address to database
contract := &models.Contract{
    Address: addr.Hex(),
    Name: "MyToken",
    DeployedAt: time.Now(),
}
db.CreateContract(contract)
```

### Pattern 2: Listen for Events

```go
// Create filter query
query := ethereum.FilterQuery{
    Addresses: []common.Address{contractAddress},
}

// Subscribe to logs
logs := make(chan types.Log)
sub, err := client.SubscribeFilterLogs(context.Background(), query, logs)

// Process events
for {
    select {
    case log := <-logs:
        // Handle event
    case err := <-sub.Err():
        // Handle error
    }
}
```

### Pattern 3: Batch Operations

```go
// Read multiple values efficiently
var (
    name string
    symbol string
    totalSupply *big.Int
)

g := new(errgroup.Group)
g.Go(func() error {
    name, err = token.Name(opts)
    return err
})
g.Go(func() error {
    symbol, err = token.Symbol(opts)
    return err
})

if err := g.Wait(); err != nil {
    // Handle error
}
```

## üéØ Next Steps

1. ‚úÖ Write your smart contract in Solidity
2. ‚úÖ Compile with `solc`
3. ‚úÖ Generate Go bindings with `abigen`
4. ‚úÖ Create controller methods
5. ‚úÖ Add routes
6. ‚úÖ Test on local network
7. ‚úÖ Deploy to testnet
8. ‚úÖ Test on testnet
9. ‚úÖ Deploy to mainnet (when ready)

## üìñ Additional Resources

- [Go-Ethereum Documentation](https://geth.ethereum.org/docs)
- [Solidity Documentation](https://docs.soliditylang.org)
- [OpenZeppelin Contracts](https://docs.openzeppelin.com/contracts)
- [Ethereum JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/)

---

**You're all set to build blockchain-enabled features in Go!** üöÄ

